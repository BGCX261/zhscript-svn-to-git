#summary zhscript简介

= zhscript简介 =
zhscript是一种脚本语言，按照我的理解，脚本一般是用在增加灵活性、降低复杂度等场合，zhscript便是以此为目标并结合母语习惯来实现的一种脚本，下面我就以与c++相对比的方式来解释他的语法

首先也从hello,world开始

c++:

cout<<"你好，这个世界";

zhscript:

显示你好，这个世界。

逻辑判断上

c++:

if(1<2&&1<=3||1>0)
	cout<<"这就对了";
else
	cout<<"这不可能";

zhscript:

如果1小于2并且1小于等于3或者1大于0那么
	显示“这就对了”
否则
	显示这不可能。

（“这就对了”之所以加引号强调是文本是因为“了”是一个关键字，“不”也是关键字，但他不在此场合起作用）

zhscript还有一种左缺省值的设计，上面的语句也可写成

如果1小于2并且小于等于3或者大于0那么
	显示“这就对了”
否则
	显示这不可能。

三元运算符

c++:

cout<<"这"<<(1<2&&1<=3||1>0 ? "就对了" : "不可能");

zhscript:

显示这如果1小于2并且小于等于3或者大于0那么“就对了”否则不可能。

c++是严格的三元，也就是说后面的两元不能缺一，而zhscript只是一种“如果”的写法，允许写成

显示这如果1小于2并且小于等于3或者大于0那么“就对了”。

分支判断

c++:

int i=0;

switch(i){

case 1:
	cout<<"壹";
	break;
case 2:
	cout<<"贰";
	break;
case 3:
	cout<<"叁";
	break;
default:
	cout<<"其他";
}

zhscript:

赋予i以0。

当‘i’先

等于1那么
	显示壹，
	跳出。
等于2那么
	显示贰，
	跳出。
等于3那么
	显示叁，
	跳出。
那么
	显示其他。
了。

其实实现上“当”是“如果”又一种的写法，所以不似c++样限于整数、只能“等于”判断，允许写成

当‘i’

先
	等于壹或者等于贰或者等于叁那么显示1-3，跳出。

	大于等于1并且小于等于3那么

	先
		显示壹至叁。
		跳出。
	了。
了。

注释

c++:

/{{{*}}}代码是最好的注释{{{*}}}/

zhscript:

（代码是最好的注释）

zhscript没有类似c++的“//”样的行式注释

文本（字符串）

c++:

包含在引号内的为文本或者字符

zhscript:

包含在双引号（中文符号）内的为绝对文本，不是关键字的代码都视为文本，包括不在适用场合的关键字

zhscript不似c++具有各种数据类型，没有数据类型或者只有字符串这一种类型，只是在一些场合（如逻辑判断、函数调用）会先处理成某种类型（如数字）以切合实际

变量的赋值和求值

c++:

string s="值";

cout<<"s="<<s<<endl;

zhscript:

赋予s以值。

显示s=‘s’字符10。

从以上可以看出zhscript的求值写法跟php、sh等的$()类似，是需要明确的求值符（一对单引号，中文符号）

zhscript对作为变量名的符号没有限制（c++是字母、数字、下划线），关键字加上引号也能作为变量名，下面的语句都被允许

定义{{{*(^-^)*}}}以“显示一定要快乐”。{{{*(^-^)*}}}。

赋予“显示”以参数是‘参数’。显示‘显示’。

如上所示，zhscript还有“参数”这样的系统变量，“参数”表示所有的命令行指定或“加载”时附带的参数，“参数1”指第1个参数，“参数数目”指参数数目

另外还有“窗口”、“保留字”、“参数栈”、“回调”等系统变量

变量指针

c++:

string s="值";

string{{{*}}} s1=&s;

string{{{**}}} s2=&s1;

cout<<"s="<<{{{**}}}s2<<endl;

zhscript:

赋予s以值。

赋予s1以s。

赋予s2以s1。

显示s=‘‘‘s2’’’字符10。

变量的作用域

c++:

面向对象，以类定义的层次形成作用域并能限定访问

zhscript:

不面向对象，以文件（解释）调用的层次形成作用域，所有上级文件的变量都可见乃至可写（只读变量除外），对于上级的访问使用注解符，用类似“变量1【上】”、“变量1【上】【上】”来访问上一级、上上一级的变量，用“变量1【顶】”访问顶级全局变量

不面向对象会出现一个用作库函数的变量名同名如何处理的问题，变量名允许通过带注解符（“【”和“】”）来指定更细的归属，如“函数1【/path/lib1】”，
在没有其他“函数1”变量的情况下，“函数1”、“函数1【lib1】”、“函数1【/path/lib1】”指的是同一个变量，

如果同时间又有一个变量“函数1【/path/lib2】”，那将存在两个“函数1”，而对“函数1”求值所得结果为最近的创建值

循环

c++:

string s="";

for(;;){
	if(s=="11111")break;

	cout<<s<<endl;

	s+="1";
}

zhscript:

赋予s以“”。

循环先
	如果‘s’等于11111那么跳出。

	显示‘s’字符10。

	赋予s以‘s’1。
了。

zhscript只支持单纯的循环，没有参数，也就是仅相当于c++的for(;;)或while(true)，支持循环操作break（关键字“跳出”）、continue（关键字“再来”），个人见解觉得for、while、do-while复杂了，参数本与循环无关

语句体

c++:

{
	cout<<1;

	cout<<2;
}

zhscript:

先
	显示1。

	显示2。
了。

zhscript另外支持一种只用于逻辑判断后的语句体，用逗号分隔，类似“如果不‘假’那么显示那就是，显示真。”的写法，也明显这种语法不能嵌套

关系运算符

c++:

{{{==、!=、<=、<、>=、>、!、&&、||}}}

zhscript:

等于、不等于、小于等于、小于、大于等于、大于、不、并且、或者

宏定义

c++:

#define out(arg) cout<<arg

out("明天有零星小雨");

zhscript:

定义out以“显示‘参数’。”。

out明天有零星小雨。

或者写成

out：明天有零星小雨。（冒号是“被忽略”的关键字，只为分隔、清晰用）

zhscript的定义也类似其他脚本的function的定义

由于定义的名字使用时也是如同关键字样不是依靠空格等分界、从语句中识别而非仅从头，所以，对很短的字母、数字、常用的单字进行定义是种很糟糕的做法，因为极有可能会导致运行大混乱

“显示”、“执行”这两个已有关键字允许被重定义，这样可以更灵活地利用已有的代码逻辑，在上一级重定义后输出便转向了

定义时除可以使用赋值的注解符外，另有“无参”用于没有参数的场合，例如“定义↙【顶】【锁】【无参】以“字符10”。”便是把“↙”定义成换行符，用在“显示明天↙有↙零星小雨↙。”，而如果不是“无参”那便达不到所期待的效果，有兴趣可以试验下

执行外部程序

c:

int ret=system("ls /");

zhscript:

赋予ret以执行“ls /”。

用于调用其他库的“调用”关键字

“调用”是用来调用系统库、第三方库、扩展库或定制shell的接口，他又由一系列类似于c写法的参数来组成

1、L用于装载库，如“赋予标准库【顶】【锁】以调用L、libstdc++.so.6.0.13、libstdc++.so.6、libstdc++-libc6.1-1.so.2。”就是去寻找装入stdc系统库，成功后句柄值将赋给变量“标准库”，后面的多个名字是为了处理库会有名字不同的情况

2、G用于获得库里函数的地址以及返回值、参数的情况，如“赋予格输出函数【顶】【锁】【标准库】以调用“G i”、‘标准库【顶】’、printf、c{{{*}}}、.。”就是获取函数printf的地址，然后与函数的返回类型、参数的类型和顺序结合起来，成功后“格输出函数”被赋予的值类似“i/6d5130/c{{{*}}}”这样保留了调用所需信息的格式串

接口的类型支持c（字符，对应char）、i（整数，对应int）、v（对应void）、u（无符号、对应unsigned）、l（长整、对应long）、{{{*}}}（指针）、&（地址）、.（可变参数）、p（pascal调用约定）等标准方式
也支持一类扩展专用类型，如Z（传递int argc,...）、S（传递char{{{*}}} buf,int siz）、B（传递char{{{*}}} buf）、E（传递int{{{*}}} err）、A（char{{{**}}} addr_ret）、$（预设值，有$、$0至$22、${{{{*字符串}、${l长整数}、${u无符号长整数}}}}）等，在gtkmmsh、zhscript_firefox_plugin等里使用的“隧道”便是使用此类

3、F用于卸载库，如“调用F、‘标准库’。”

4、函数调用，如“调用‘格输出函数’-c-i-lu-c{{{*}}}、%c字符9%d字符9%lu字符9%s字符10、c、21、2100000000、string。”

嵌套的赋值

c:

int i1,i2,i3;

i1=i2=i3=100;

zhscript:

赋予i1以赋予i2以赋予i3以100。

另外，“显示”关键字也支持这种嵌套，如“显示显示显示哈哈”将会显示6个哈

变量的其他

c++:

delete p;

zhscript:

删除p。

zhscript还有类似于php的isset、bash的-z等的判断变量是否存在的关键字“存在”

类似sql的alias用法的关键字“别名”，用于给参数起名字或需要一个变量有多个名字的地方

运行其他地方的代码

加载：运行文件里的代码，可附带参数

解释：运行一段代码，可附带参数。这段代码也可以是一个变量，所用变量在赋值时一般得标识其为代码以免当时被解释，方法是变量加“代码”注解符等

流程的直接终止

结束：整个结束

退出：当前级（区）结束

类似于一些语言的with的“基于”关键字

对于可以自解释的解释语言来说，with是比在编译语言里更有用武之地，因为他可以使书写的尤其是来自输入框的代码更专注于表达某一逻辑

类似PHP的EOT定界符的“下原样”、“上原样”关键字

“下原样”/“上原样”成对出现，之间的所有字符将原样使用，包括换行、回车、制表符等被忽略字符

用于标示代码段的“下代码”、“上代码”关键字

用引号标注的文字段支持使用注解符从而变为代码或原样文字，即类似“【代码】“代码段””、“【原样】“原样文字””这样的写法

系统变量“回调”的含义，主要用于其他程序或库直接使用解释器

回调：解释语句接口函数地址

回调0：当前解释器地址

回调1：区地址

回调2：分配变量接口函数地址

回调3：得变量值接口函数地址

回调4：删除变量接口函数地址

回调5：遍历变量接口函数地址

回调6：解释语句（数组）接口函数地址

以上其中每个接口函数的具体定义在 http://code.google.com/p/zhscript/source/browse/trunk/new_gg/def1.h 这个头文件里

系统变量“参数栈”用于传递调用、加载等所需的整个参数栈再给下一级

“数目”、“之”

参数、保留字这些系统变量都有个-1如“参数-1”、“保留字-1”来返回他们的数目，又有“数目”关键字，便有“参数数目”、“保留字数目”相等价，另外一些扩展库会将运算结果分配成多个变量，形成数组，这个关键字也同样传给他们

“之”解释器本身并不使用，而是作为统一的数组“维”分隔符传给扩展库，这样也同时可以当解释器关键字变化（如繁体版、英文版）时不必修改扩展库

上两者使用时的一个例子：

新建数组“排”、3、

	11、12、13、

	21、22、23。
显示‘排数目’-‘排之1之1’-‘排之2之3’。

英文版：

new_array row,3,

	11,12,13,

	21,22,23;
echo $(row.length)-$(row.1.1)-$(row.2.3);